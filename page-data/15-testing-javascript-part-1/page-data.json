{
    "componentChunkName": "component---src-templates-page-index-js",
    "path": "/15-testing-javascript-part-1",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Testing Javascript (part-1)","desc":"Understand JEST setup, JestDOM, Coverage, watch mode, monkey patch","banner":{"sharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACRUlEQVQoz6WQSU9TURiGr+jKRCMCZVLiwjBWECiE+B90QYw7VBYGocO9VEOM/8AtDrG0DIUGozGKKEoQZKwtQ1tA5ZapBYUgumiBVhNpebS37nDnSd6cN+d78uScI5ybvkmFx4jGLaFxi/szLVE+UEOZQ6f0fzJukXJPPTGXUOI2cG2hkfHteexbXkaDXsaC3ngPyDjCS9zrt/JsfhBHeJmxgKzMFSboZSQg49pZxrzRq0iFIpeO234r/7tiFypzSzGhlga/DXa/YrclM2A5irPzGGMdSYx2pOLtSWNtII0+s4rJxyp6m1QMW1OQuxMVps8kEF64g/3HOhqX7q/Q1w7ssDIhMdSlZeadyIeBat4/v8BE93kCMxcZfFLJ5MtKPG8qcfVcwufUMfJCR//TK0Q332IP+dG4DDGhngZfy74nfIv9qy2BrruJODsTCY0n8frhcRy2w8y+Kt3HDwdmKfNICIWTOm4tt8VPo8DunlK316ZYsDfin2xic9bET58Jr93EsvM+m586IforzkfivDM4j2ZKQtDMiWi/PGBxb525yCpy9DNyZJVFvuMnjI8QS4SYJ4RfSZgltpGjXxT+Y2QF394Gj7aGqJCNCAWtIupWkdxmPfmtBmWPJcdSR465llxLLTmWWvJb6pSebb5OtrmWvBY96jaRgjaRwnaJM1aJ/GYDwpHTNWQUiaQXipzS3CCzSEJQXUZIqeJQZjUni+vJKjWSVWJEpdZzIP0qQnIVBzOqSc7Tkqo2cKK4nsyzEgl/Zr8BtaxJd12mhoMAAAAASUVORK5CYII=","aspectRatio":1.9824561403508771,"src":"/static/c9cb9fa123a5203f11f22dc9c7187dfe/62b1f/15-testing-javascript-part-1.png","srcSet":"/static/c9cb9fa123a5203f11f22dc9c7187dfe/e7519/15-testing-javascript-part-1.png 113w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/7e7e9/15-testing-javascript-part-1.png 225w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/62b1f/15-testing-javascript-part-1.png 450w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/e2e7f/15-testing-javascript-part-1.png 675w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/db955/15-testing-javascript-part-1.png 900w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/a8378/15-testing-javascript-part-1.png 1024w","srcWebp":"/static/c9cb9fa123a5203f11f22dc9c7187dfe/b8a88/15-testing-javascript-part-1.webp","srcSetWebp":"/static/c9cb9fa123a5203f11f22dc9c7187dfe/3a3bf/15-testing-javascript-part-1.webp 113w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/975bf/15-testing-javascript-part-1.webp 225w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/b8a88/15-testing-javascript-part-1.webp 450w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/761da/15-testing-javascript-part-1.webp 675w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/210c1/15-testing-javascript-part-1.webp 900w,\n/static/c9cb9fa123a5203f11f22dc9c7187dfe/cc834/15-testing-javascript-part-1.webp 1024w","sizes":"(max-width: 450px) 100vw, 450px"}}}},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Testing Javascript (part-1)\",\n  \"slug\": \"/15-testing-javascript-part-1\",\n  \"date\": \"2020-05-15T00:00:00.000Z\",\n  \"desc\": \"Understand JEST setup, JestDOM, Coverage, watch mode, monkey patch\",\n  \"cover\": {\n    \"img\": \"../../../photos/15-testing-javascript-part-1.png\"\n  },\n  \"banner\": \"../../banners/15-testing-javascript-part-1.png\",\n  \"tags\": [\"JS\", \"React\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"span\", {\n    className: \"first-letter\"\n  }, \"T\"), \"his article is specially for beginners. I have covered testing JavaScript course in two parts:\"), mdx(\"p\", null, \"Below topics which will be covering in \", mdx(LinkPost, {\n    href: \"/15-testing-javascript-part-1\",\n    name: \"this part\",\n    mdxType: \"LinkPost\"\n  }), \":\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"JEST Setup\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Import/Modules\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"JestDOM\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Handling Dynamic Imports\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"COVERAGE\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Watch Mode\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Monkey Patch\")), mdx(\"p\", null, \"Below are the topics which I\\u2019m going to cover in the \", mdx(LinkPost, {\n    href: \"/16-testing-javascript-part-2\",\n    name: \"second part\",\n    mdxType: \"LinkPost\"\n  }), \":\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"React Testing Library\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Snapshot Testing\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Integration Testing\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Cypress\")), mdx(\"h2\", null, \"JEST\"), mdx(\"p\", null, \"Jest is a JavaScript test runner, i.e, a JavaScript library for creating, running, and structuring tests.\"), mdx(\"p\", null, \"Test cases will be in this form:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Arrange\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Act\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assert\")), mdx(\"p\", null, \"First create a container where you have to see the value, to render things(as DOM). Then, act accordingly and then check or validate.\"), mdx(\"h3\", null, \"1\\uFE0F\\u20E3 JEST Setup \\uD83D\\uDDA5\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"$ npm install --save-dev jest\\n\")), mdx(\"u\", null, \"package.json\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"scripts\\\":{\\n    \\\"test\\\": \\\"jest\\\"\\n}\\n\")), mdx(\"p\", null, \"The test file extension can be in tests folder with extension names as: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.js\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.jsx\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.test.js/jsx\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.spec.js/jsx\")), mdx(\"h3\", null, \"2\\uFE0F\\u20E3 Import / Modules \\u23E3\"), mdx(\"p\", null, \"Now, when you import some components in test file, where import will throw an error because babel configuration should be set to trample everything except for imports.\"), mdx(\"blockquote\", null, mdx(\"b\", null, \"Why should we not trample imports when we are using Webpack\"), \"\\u2753 \\uD83E\\uDD14\", mdx(\"p\", null, \"Because webpack supports ES modules. And the reason that Webpack supports ES modules is so it can do tree shaking.\\nWhich enable to skip some import, will remove the dead code and our bundler will be smaller.\")), mdx(\"p\", null, \"To make import work in test file, you have to make few changes in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"babelrc.js\"), \". You have to change the modules in preset from false to commonjs, which will enable the import to work in test files.\"), mdx(\"p\", null, mdx(\"mark\", null, \"NOTE\"), \": Make sure setting module preset to commonjs works only in test/local environment.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".babelrc\"), \" file only supports JSON, to make it JS supported you need to reset here:\"), mdx(\"u\", null, \"package.json\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"babel\\\": {\\n    \\\"presets\\\" : \\\"./babelrc.js\\\"\\n}\\n\")), mdx(\"p\", null, \"Now you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"babelrc.js\"), \", where you can write your JS as well.\"), mdx(\"h3\", null, \"3\\uFE0F\\u20E3 JestDOM\"), mdx(\"p\", null, \"By default, Jest loads JSDOM in environment. So, if you \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log(window)\"), \", it will return window object, all events which loads in window.\"), mdx(\"p\", null, \"If the test project is in pure javascript, then you don\\u2019t actually need to access the window. By adding JSDOM, its pretty heavy memory wise.\"), mdx(\"p\", null, \"To configure that, you need to make a small change here:\"), mdx(\"u\", null, \"package.json:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"jest: {\\n  \\\"testEnvironment\\\": \\\"jest-environment-jsdom\\\" \\n  // it will get downloaded when we install \\n}\\n\")), mdx(\"p\", null, \"After adding the above line, if you c\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onsole.log(window)\"), \" in JS file, then test will throw an error.\"), mdx(\"h4\", null, mdx(\"mark\", null, \"CSS Imports\")), mdx(\"p\", null, \"Before installing CSS imports, The CSS also will get treated as JS module and will throw error while using class as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".color {}\"), \" in any component or page. As we know, Node can\\u2019t import CSS, it deals with JSON or JS. \\uD83D\\uDE2E\"), mdx(\"p\", null, \"Creating a separate file for jest config in root:\"), mdx(\"u\", null, \"jest.config.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"module.exports = {\\n  \\\"modulesNameMapper\\\": {\\n    '\\\\\\\\.css$': require.resolve('./styleMock') // this file will be empty \\n  }\\n}\\n\")), mdx(\"u\", null, \"styleMock.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"module.exports = {}\\n\")), mdx(\"p\", null, \"By above snippet, CSS import issue will get resolved. \\uD83D\\uDE0E\"), mdx(\"p\", null, \"But as you know, you are using CSS modules in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.(className = {styles.name})\")), mdx(\"p\", null, \"As you have added the above file(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styleMock\"), \") which is empty. When you console log in the test file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"div.innerHTML\"), \", then no class will be shown because you are passing empty style mock file.\"), mdx(\"p\", null, \"So when component get called, and check styles file it will find empty object as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"module.exports = {}\")), mdx(\"p\", null, \"You can fix it in very easy way by installing module name \\u2013 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Identity object Proxy\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"$ npm install \\u2014save-dev identity-object-proxy\\n\")), mdx(\"u\", null, \"jest.config.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"module.exports = {\\n  \\\"modulesNameMapper\\\": {\\n        '\\\\\\\\module\\\\\\\\.css$' : 'identity-obj-proxy',\\n                '\\\\\\\\.css$': require.resolve('./styleMock') // this file will be empty \\n  }\\n}\\n\")), mdx(\"h3\", null, \"4\\uFE0F\\u20E3 Handling Dynamic Imports\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"When import error comes? How to convert dynamic import into the node equivalent? \\uD83E\\uDD14\")), mdx(\"p\", null, \"Install the plugin name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"babel-plugin-dynamic-import-node\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"$ npm install \\u2014save-dev babel-plugin-dynamic-import-node\\n\")), mdx(\"u\", null, \".babelrc.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"plugins: [\\n    isTest? 'dynamic-import-node' : null\\n].filter(Boolean)\\n\")), mdx(\"p\", null, \"As null is not a plugin for babel, and it throw error. So, you will filter by boolean. Problem solved \\uD83D\\uDE0A\"), mdx(\"blockquote\", null, mdx(\"b\", null, \"What about localStorage? How do we test that?\"), mdx(\"p\", null, \"As JSDOM, doesn't support localStorage will add the localStorage file to mock localStorage support.\")), mdx(\"u\", null, \"localStorage.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"if (!window.localStorage) {\\n  window.localStorage = {}\\n  Object.assign(window.localStorage, {\\n    removeItem: function removeItem(key) {\\n    delete this[key]\\n  }.bind(window.localStorage),\\n  setItem: function setItem(key, val) {\\n    this[key] = String(val)\\n  }.bind(window.localStorage),\\n  getItem: function getItem(key) {\\n    return this[key]\\n  }.bind(window.localStorage),\\n  })\\n}\\n\")), mdx(\"u\", null, \"jest.config.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"module.exports = {\\n  \\\"modulesNameMapper\\\": {\\n        '\\\\\\\\module\\\\\\\\.css$' : 'identity-obj-proxy',\\n    '\\\\\\\\.css$': require.resolve('./styleMock') // this file will be empty \\n  },\\n    setupTestFrameworkScriptFile: require.resolve(\\u2018./localStorage.js\\u2019)\\n}\\n\")), mdx(\"p\", null, \"Now you can use the localStorage \\uD83D\\uDE0E\"), mdx(\"h3\", null, \"5\\uFE0F\\u20E3 Covergae \\uD83D\\uDCCA\"), mdx(\"p\", null, \"The most useful part in JEST which I use frequently, is to check code coverage. Coverage is good to know what are the things has missed for testing.\"), mdx(\"u\", null, \"package.json:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"scripts\\\": {\\n    \\\"test\\\": \\\"jest --coverage\\\"\\n}\\n\")), mdx(\"p\", null, \"Once you run this, it will generate a coverage report in coverage folder, inside Icov-report/index.html, that will open coverage file.\"), mdx(\"p\", null, \"Now, If you want to see the coverage for only those files which is in src folder then we can do this:\"), mdx(\"u\", null, \"jest.config.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"module.exports = {\\n  \\\"modulesNameMapper\\\": {\\n        '\\\\\\\\module\\\\\\\\.css$' : 'identity-obj-proxy',\\n    '\\\\\\\\.css$': require.resolve('./styleMock') // this file will be empty \\n  },\\n    setupTestFrameworkcriptFile: require.resolve(\\u2018./localstorage-filename\\u2019),    \\n    collectCoverageFrom : [\\n        '** /src/**/*.js'\\n    ]\\n}\\n\")), mdx(\"p\", null, \"If you want to put some limit for test cases, let\\u2019s say 90%, then only we should able to push the changes into repository else it should throw error saying test has not passed threshold coverage. So, you can add coverage threshold.\"), mdx(\"u\", null, \"jest.config.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"module.exports = {\\n  \\\"modulesNameMapper\\\": {\\n        '\\\\\\\\module\\\\\\\\.css$' : 'identity-obj-proxy',\\n    '\\\\\\\\.css$': require.resolve('./styleMock') // this file will be empty \\n  },\\n    setupTestFrameworkcriptFile: require.resolve(\\u2018./localstorage-filename\\u2019),    \\n    collectCoverageFrom : [\\n        '** /src/**/*.js'\\n    ],\\n    coverageThreshold: {\\n        \\\"./src/state/\\\": {\\n         \\\"functions\\\": 70\\n     }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Threshold can also be added on statement, functions and branches.\"), mdx(\"p\", null, \"In code coverage: those which are in red, don\\u2019t have test cases/coverage.\"), mdx(\"h3\", null, \"6\\uFE0F\\u20E3 Watch Mode \\uD83D\\uDD76\"), mdx(\"p\", null, \"Watch mode is also awesome feature of JEST, where you can run test on the basis of file name or on files which follow some pattern. Specially when you make some changes in file, then it will run only those files for watch mode.\"), mdx(\"u\", null, \"package.json:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"scripts\\\": {\\n    \\\"test:watch\\\":  \\\"jest \\u2014watch\\\"\\n}\\n\")), mdx(\"p\", null, \"Following is an example for handleSubmit:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"handleSubmit = e => {\\n    e.preventDefault()\\n    const {title, content, tags} = e.target.elements\\n    const newPost = {\\n      title: title.value,\\n      content: content.value,\\n      tags: tags.value.split(',').map(t => t.trim()),\\n      date: new Date().toISOString(),\\n      authorId: this.props.user.id,\\n    }\\n    api.posts.create(newPost).then(() => {\\n      this.props.history.push('/')\\n    })\\n  }\\n\")), mdx(\"u\", null, \"test.js:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import React from 'react';\\nimport ReactDOM from 'react-dom'\\nimport * as utilMock from '../../utils/api'\\nimport EditorTodo from '../editor.todo'\\n\\n// to fix the post of undefined, we need to mock the API\\njest.mock(\\\"../../utils/api\\\", () => {\\n  return {\\n    posts: {\\n      // .then , where we need to return a promise\\n      create: jest.fn(() => Promise.resolve())\\n    }\\n  }\\n})\\n\\nconst flushPromise = () => {\\n  return new Promise(resolve => {\\n    setTimeout(resolve, 0)\\n  })\\n}\\n\\ntest('calls onSubmit with the username and password when submitted', async () => {\\n  const conatiner = document.createElement(\\\"div\\\");\\n  // authorId is expecting some user in test.\\n  const fakeUser = {id: 'bar'}\\n  // create react-router history mock\\n  const fakeHistory = {\\n    push: jest.fn()\\n  }\\n  ReactDOM.render(<EditorTodo user={fakeUser} history={fakeHistory} />, conatiner)\\n\\n  const form = conatiner.querySelector('form');\\n  const {title, content, tags} = form.elements;\\n  title.value='Hello'\\n  content.value='Coming here!'\\n  tags.value=\\\"something,     which,   is  ,here\\\"\\n\\n  const submit = new window.Event('submit');\\n  form.dispatchEvent(submit)\\n  // assertion\\n  // it throw error because fakeHistory is aynchronous, so we need to wait unti its not resolved,\\n  // So, we will write function for resolve\\n  // And that's why I made the function async\\n  await flushPromise()\\n\\n  expect(fakeHistory.push).toHaveBeenCalledTimes(1)\\n  // as we are redirecting to the homepage /\\n  expect(fakeHistory.push).toHaveBeenCalledWith('/')\\n  expect(utilMock.posts.create).toHaveBeenCalledTimes(1)\\n  expect(utilMock.posts.create).toHaveBeenCalledWith({\\n    authorId: fakeUser.id,\\n    title: title.value,\\n    content: content.value,\\n    tags: ['something', 'which', 'is', 'here'],\\n    date: expect.any(String)\\n  })\\n})\\n\")), mdx(\"h3\", null, \"7\\uFE0F\\u20E3 Monkey Patch \\uD83D\\uDC35\"), mdx(\"p\", null, \"If you modify any functions in test file then we have to take care of the original function as well, as its also getting changed. We can use spyOn / Mock to create mock function, that will solve our problem.\"), mdx(\"p\", null, \"If you change any function in test file, then it will change to main function as well. SO, If we change anything functions in test file then we have to take care of the main function as well, as its also getting changed. After completion of test, we should return the actual function.\"), mdx(\"p\", null, \"This, will get solved by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"spyOn / Mock.\")), mdx(\"mark\", null, \"SPYON\"), mdx(\"p\", null, \"Creates a mock function similar to jest.fn but also tracks calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object[methodName]\"), \".\"), mdx(\"p\", null, \"By default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.spyOn()\"), \" does not override the implementation (this is the opposite of jasmine.spyOn). If you don\\u2019t want it to call through, you have to mock the implementation, using mockImplementation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"jest.mock\"), \": Mock a module\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"jest.spyOn\"), \": Spy or mock a function\")), mdx(\"p\", null, \"But, instead of using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.spyOn\"), \", mock is great. Because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.spyOn\"), \" is based on naming convention , which is not good. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.mock\"), \" does this automatically for all functions in a module. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.spyOn\"), \" does the same thing but allows restoring the original function.\"), mdx(\"mark\", null, \"JEST.MOCK\"), mdx(\"p\", null, \"It mocks a module.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"Jest.mock(\\n\\n    relativePathToModuleToMock, // what to we want to module to look like\\n\\n    functionThatReturnObject // so this function will return what we want the module to look like\\n\\n)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Jest.mock(apiPath, function or export module part )\")), mdx(\"p\", null, \"In this section, we learnt how to setup JEST, understand concept of JSDOM, CSS module, Handling Dynamic Imports, we learn how useful Test Coverage is, and how can save a lot of time using Watch Mode.\"), mdx(LinkPost, {\n    href: \"/16-testing-javascript-part-2\",\n    name: \"Next section\",\n    mdxType: \"LinkPost\"\n  }), \" we are going to discuss following topics: React Testing Library, Snapshot Testing, Integration Testing and Cypress\", mdx(\"p\", null, \"I hope you found this blog helpful, If you have any question please reach out to me on \", mdx(LinkPost, {\n    href: \"https://twitter.com/suprabhasupi\",\n    name: \"@suprabhasupi\",\n    mdxType: \"LinkPost\"\n  }), \" \\uD83D\\uDE0B\"), mdx(\"h2\", null, \"Reference \\uD83E\\uDDD0\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(LinkPost, {\n    href: \"https://frontendmasters.com/courses/testing-react/\",\n    name: \"Frontend Master Testing React\",\n    mdxType: \"LinkPost\"\n  }))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/15-testing-javascript-part-1"}},
    "staticQueryHashes": ["1691836396"]}