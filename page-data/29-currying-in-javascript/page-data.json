{
    "componentChunkName": "component---src-templates-page-index-js",
    "path": "/29-currying-in-javascript",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Currying in JavaScript","desc":"Currying is a process in functional programming in which we can transform a function with multiple arguments into a sequence of nesting functions.","banner":{"sharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB2klEQVQozz2RS28SYRiF+YVdKIGZ0S40ZacbL4m1ica4s0YTF7ZKEEK41KiVKtVqbGhcGF24IpViGIYBOtyhXOZmO/OYGdouTs73fouT57xvgKoIVQFXFqEmghKC2hLoMlhjMPpgDcEegTkAYzB3X8O5jNN/vUfAC/TDFIFxUcIshTiRI0w7JYxRj+NJl2lPY9hq8G/S5XjawzrqYB91MIYt/+2FuXof1xjMAx0vUBUovJNIrV/i7SuRaHSNePobG2++kszskPuw53ssue17Iv2ZWPITL+N5NrcKcDLGmfUIeHRn8iitssRs/wLd4gqDVhNNrdOuK4zadRpVmb9/yvQ1lW5TxRy1ffpOQ/VX4OoeoSyAHMYnrYjQFGj8lFh7EubZ02Vu33vB9eUYN++nSaS+8OBRisiNKA9Xs2iqAs7Y37FXGb0zr4yyiCufHqYqYJdFGr8kdjJBvucW2cre5f3rx+x9XCGfucJ2Lk65VMMYaGB0cWZtsGzc4S6BYfEWhc11qEdw5dB5KHUBR5ZwKgL2QRB9fwFTy6PXE9gHF0H/AZaJaxpgmjApgXqNgFVe4vD3HVAu+5RnV/frV+czigRKGEa70M+CvIBTkXAPV6G7gdt+DspVkIP8Bw0LGboPCMKXAAAAAElFTkSuQmCC","aspectRatio":2.511111111111111,"src":"/static/71dac44e9b502b2e8912c2423f8c16d5/62b1f/29-currying-in-javascript.png","srcSet":"/static/71dac44e9b502b2e8912c2423f8c16d5/e7519/29-currying-in-javascript.png 113w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/7e7e9/29-currying-in-javascript.png 225w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/62b1f/29-currying-in-javascript.png 450w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/e2e7f/29-currying-in-javascript.png 675w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/db955/29-currying-in-javascript.png 900w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/dc180/29-currying-in-javascript.png 1260w","srcWebp":"/static/71dac44e9b502b2e8912c2423f8c16d5/b8a88/29-currying-in-javascript.webp","srcSetWebp":"/static/71dac44e9b502b2e8912c2423f8c16d5/3a3bf/29-currying-in-javascript.webp 113w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/975bf/29-currying-in-javascript.webp 225w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/b8a88/29-currying-in-javascript.webp 450w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/761da/29-currying-in-javascript.webp 675w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/210c1/29-currying-in-javascript.webp 900w,\n/static/71dac44e9b502b2e8912c2423f8c16d5/cc5e2/29-currying-in-javascript.webp 1260w","sizes":"(max-width: 450px) 100vw, 450px"}}}},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Currying in JavaScript\",\n  \"slug\": \"/29-currying-in-javascript\",\n  \"date\": \"2020-07-08T00:00:00.000Z\",\n  \"desc\": \"Currying is a process in functional programming in which we can transform a function with multiple arguments into a sequence of nesting functions.\",\n  \"cover\": {\n    \"img\": \"../../../photos/29-currying-in-javascript.png\"\n  },\n  \"banner\": \"../../banners/29-currying-in-javascript.png\",\n  \"tags\": [\"JS\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"span\", {\n    className: \"first-letter\"\n  }, \"C\"), \"urrying is a process in functional programming in which we can transform a function with multiple arguments into a sequence of nesting functions. It returns a new function that expects the next argument inline.\"), mdx(\"p\", null, \"In other words, when a function, instead of taking all arguments at one time, takes the first one and return a new function that takes the second one and returns a new function which takes the third one, and so forth, until all arguments have been fulfilled.\"), mdx(\"p\", null, \"That is, when we turn a function call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum(1,2,3)\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum(1)(2)(3)\")), mdx(\"p\", null, \"The number of arguments a function takes is also called \", mdx(\"mark\", null, \"arity\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum(a, b) {\\n    // do something\\n}\\nfunction _sum(a, b, c) {\\n    // do something\\n}\\n\")), mdx(\"p\", null, \"Function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" takes two arguments (2-arity function) and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_sum\"), \" takes three arguments (3-arity function).\"), mdx(\"p\", null, \"Curried functions are constructed by chaining closures by defining and immediately returning their inner functions simultaneously.\"), mdx(\"h2\", null, \"Why it\\u2019s useful\\u2753\\uD83E\\uDD14\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Currying helps we avoid passing the same variable again and again\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It helps to create a higher order function\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Currying\"), \" transforms a function with multiple arguments into a sequence/series of functions each taking a single argument.\"), mdx(\"u\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum(a, b, c) {\\n    return a + b + c;\\n}\\n\")), mdx(\"p\", null, \"This function takes three numbers, add the numbers and returns the result.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"sum(1,2,3); // 6\\n\")), mdx(\"p\", null, \"As we see, function with the full arguments. Let\\u2019s create a curried version of the function and see how we would call the same function (and get the same result) in a series of calls:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum(a) {\\n    return (b) => {\\n        return (c) => {\\n            return a + b + c\\n        }\\n    }\\n}\\n\\nconsole.log(sum(1)(2)(3)) // 6\\n\")), mdx(\"p\", null, \"We could separate this sum(1)(2)(3) to understand it better:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const sum1 = sum(1);\\nconst sum2 = sum1(2);\\nconst result = sum2(3);\\nconsole.log(result); // 6\\n\")), mdx(\"p\", null, \"Let's get to know how it works:\"), mdx(\"p\", null, \"We passed 1 to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let sum1 = sum(1);\\n\")), mdx(\"p\", null, \"It returns the function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"return (b) => {\\n    return (c) => {\\n        return a + b + c\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now,\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum1\"), \"\\xA0holds the above function definition which takes an argument\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \".\"), mdx(\"p\", null, \"We called the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum1\"), \"\\xA0function, passing in\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let sum2 = sum1(2);\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum1\"), \" will return the third function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"return (c) => {\\n    return a + b + c\\n}\\n\")), mdx(\"p\", null, \"The returned function is now stored in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum2\"), \" variable.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum2\"), \" will be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"sum2 = (c) => {\\n    return a + b + c\\n}\\n\")), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum2\"), \" is called with 3 as the parameter,\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const result = sum2(3);\\n\")), mdx(\"p\", null, \"It does the calculation with the previously passed in parameters: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a = 1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b = 2\"), \" and returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"console.log(result); // 6\\n\")), mdx(\"p\", null, \"The last function only accepts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \" variable but will perform the operation with other variables whose enclosing function scope has long since returned. It works nonetheless because of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Closure\")), mdx(\"h2\", null, \"Currying & Partial Application \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\"), mdx(\"p\", null, \"Some might start to think that the number of nested functions a curried function has depends on the number of arguments it receives. Yes, that makes it a curry.\"), mdx(\"p\", null, \"Let's take same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \"  example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum(a) {\\n    return (b, c) => {\\n        return a * b * c\\n    }\\n}\\n\")), mdx(\"p\", null, \"It can be called like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let x = sum(10);\\nx(3,12);\\nx(20,12);\\nx(20,13);\\n\\n// OR\\n\\nsum(10)(3,12);\\nsum(10)(20,12);\\nsum(10)(20,13);\\n\")), mdx(\"p\", null, \"Above function expects 3 arguments and has 2 nested functions, unlike our previous version that expects 3 arguments and has 3nesting functions.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This version isn\\u2019t a curry.\"), \" We just did a partial application of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" function.\"), mdx(\"p\", null, \"Currying and Partial Application are related (because of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"closure\"), \"), but they are of different concepts.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Partial application transforms a function into another function with smaller arity.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum1(x, y, z) {\\n    return sum2(x,y,z)\\n}\\n\\n// to\\n\\nfunction sum1(x) {\\n    return (y,z) => {\\n        return sum2(x,y,z)\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum1(x) {\\n    return (y) => {\\n        return (z) => {\\n            return sum2(x,y,z)\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Currying\"), \" creates nesting functions according to the number of the arguments of the function. Each function receives an argument. If there is no argument there is no currying.\"), mdx(\"p\", null, \"To develop a function that takes a function and returns a curried function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function currying(fn, ...args) {\\n    return (..._arg) => {\\n        return fn(...args, ..._arg);\\n    }\\n}\\n\")), mdx(\"p\", null, \"The above function accepts a function (fn) that we want to curry and a variable number of parameters(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2026args\"), \"). The rest operator is used to gather the number of parameters after fn into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"...args\"), \".\"), mdx(\"p\", null, \"Next, we return a function that also collects the rest of the parameters as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2026_args\"), \". This function invokes the original function fn passing in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"...args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"..._args\"), \" through the use of the spread operator as parameters, then, the value is returned to the user.\"), mdx(\"p\", null, \"Now, we can use the above function to create curry function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function sum(a,b,c) {\\n    return a + b + c\\n}\\n\\nlet add = currying(sum,10);\\nadd(20,90); // 120\\nadd(70,60); // 140\\n\")), mdx(\"mark\", null, \"Closure\"), \" makes currying possible in JavaScript. I hope you have learned something new about currying!\", mdx(\"p\", null, \"Thanks for reading this article \\u2665\\uFE0F\"), mdx(\"p\", null, \"If you have any question, please feel free to ping me on \", mdx(LinkPost, {\n    href: \"https://twitter.com/suprabhasupi\",\n    name: \"@suprabhasupi\",\n    mdxType: \"LinkPost\"\n  }), \" \\uD83D\\uDE0B\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/29-currying-in-javascript"}},
    "staticQueryHashes": ["1691836396"]}