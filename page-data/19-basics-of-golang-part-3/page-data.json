{
    "componentChunkName": "component---src-templates-page-index-js",
    "path": "/19-basics-of-golang-part-3",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Basics Of GoLang (part-3)","desc":"Understand Pointers, error handling, methods, interface in GO","banner":{"sharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACpklEQVQozzWR7UtTARTG7x8QUUQvFvilT0JvVH9ERCaFkFS2aPPO5abTtDcxgiKCwg+6soSCjCDoDbQslXK2uba73Vm723T33ul0llY206lpFr+4kw6c8xzOOc9zPjyCI5jELsWw9LqxBzXsQZ3KoI4zpFMT0qn+OMq5LjfN9xu53P6SSkmjQtKxSSrlkoZN0jgtrfAMFGxymmM9jzBfKuGY5KM8OIIoqdiMg6CG2TdIVX013rYbPGlrwulTsIR0rFICMZCgTFIRQzpiSKNcUhGsks4pbwDzi2dYPkQQPTFEbxSTf4iTAZXKHi/XHz/gWq+Pal8MkzeGRdIw+RO5Z9aAihjUEP1DWPvjCEYp8yUwD4xh6oti6pYp7ZZpjKb4vLjM8M8steERLoRVbshx5KlZppaWcX+dpkrWMXvjiO8VLB4F63sFQeyPY+2LcOVTEld8jKthnaZoCiMS01ma5SH2PffQ4AnzLfODxPQcb1KTuX3g+wwn3Apl7gjmPgWrbxChwp/gSiTFXfULHePfuad/QZ9dYHx+kYZwEv9khjeRCENTM6QXfuMIqJT0RemdyDC3/Ie6UBKHP0G1YahhijOoU2M4K2k0DAxzVk6Szv4inV3gZnSMTz+y/I/Pc784Jyc5H04yMb/I8Mw8Br9OXuEZGkKtMkp9fJyL8TQXYmM4IymeT07nBGaBBWBk6TdPJjK52RKwDPwFXCNfOaOMct7I6GiuF4paOilu7aLQ1cFBVzuFze0U3u6k7uE7HnQEaHzqpbjlFQfuvKam7S332/00PfNS2vqaQ61dHG7ppOjWCne/qwNh1dYyNu2ws3GHnfy9TvJ2OhA2HEdYW5LDtdsr2LK7ivw9VawuKEdYfxRhzRGEvFLWFdhYv+00m3dVkrfLkZv9A4+3WWEgWeuYAAAAAElFTkSuQmCC","aspectRatio":1.9824561403508771,"src":"/static/621a6ad1bbd5bc2855a5c93d6ededdc0/62b1f/19-basics-of-golang-part-3.png","srcSet":"/static/621a6ad1bbd5bc2855a5c93d6ededdc0/e7519/19-basics-of-golang-part-3.png 113w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/7e7e9/19-basics-of-golang-part-3.png 225w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/62b1f/19-basics-of-golang-part-3.png 450w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/e2e7f/19-basics-of-golang-part-3.png 675w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/db955/19-basics-of-golang-part-3.png 900w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/a8378/19-basics-of-golang-part-3.png 1024w","srcWebp":"/static/621a6ad1bbd5bc2855a5c93d6ededdc0/b8a88/19-basics-of-golang-part-3.webp","srcSetWebp":"/static/621a6ad1bbd5bc2855a5c93d6ededdc0/3a3bf/19-basics-of-golang-part-3.webp 113w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/975bf/19-basics-of-golang-part-3.webp 225w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/b8a88/19-basics-of-golang-part-3.webp 450w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/761da/19-basics-of-golang-part-3.webp 675w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/210c1/19-basics-of-golang-part-3.webp 900w,\n/static/621a6ad1bbd5bc2855a5c93d6ededdc0/cc834/19-basics-of-golang-part-3.webp 1024w","sizes":"(max-width: 450px) 100vw, 450px"}}}},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Basics Of GoLang (part-3)\",\n  \"slug\": \"/19-basics-of-golang-part-3\",\n  \"date\": \"2020-05-28T00:00:00.000Z\",\n  \"desc\": \"Understand Pointers, error handling, methods, interface in GO\",\n  \"cover\": {\n    \"img\": \"../../../photos/19-basics-of-golang-part-3.png\"\n  },\n  \"banner\": \"../../banners/19-basics-of-golang-part-3.png\",\n  \"tags\": [\"GO\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"span\", {\n    className: \"first-letter\"\n  }, \"W\"), \"e covered many topics in \", mdx(LinkPost, {\n    href: \"/17-basics-of-golang-part-1\",\n    name: \"Part-1\",\n    mdxType: \"LinkPost\"\n  }), \" and \", mdx(LinkPost, {\n    href: \"/18-basics-of-golang-part-2\",\n    name: \"Part-2\",\n    mdxType: \"LinkPost\"\n  }), \". If you have not read those parts, I would recommend to check it out first as creating variable, all control statements and data types are added into the first blog for \", mdx(LinkPost, {\n    href: \"/17-basics-of-golang-part-1\",\n    name: \"Basics Of GoLang Part-1\",\n    mdxType: \"LinkPost\"\n  }), \", and Functions, Array, Toolkit, Packages, Unit Testing and Structs has explained in \", mdx(LinkPost, {\n    href: \"/18-basics-of-golang-part-2\",\n    name: \"Basics Of GoLang Part-2\",\n    mdxType: \"LinkPost\"\n  }), \".\"), mdx(\"p\", null, \"We will continue with the following topics in this section:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pointers\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Error Handling\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Methods\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Interface\")), mdx(\"h2\", null, \"1\\uFE0F\\u20E3 Pointers \\u25BA\"), mdx(ImgPost, {\n    src: Pointers,\n    alt: \"pointers in go\",\n    width: 60,\n    mdxType: \"ImgPost\"\n  }), mdx(\"p\", null, \"A variable that holds into the memory location of that variable instead of copy its value.\"), mdx(\"p\", null, \"To do that we need to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pointer\"), \".\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Pointer type definitions are indicated with a * next to the type name\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Indicate that the variable will point to a memory location.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var namePointer *string\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Pointer variable values are visible with a * next to the variable name\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var nameValue = *namePointer\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To read through a variable to see the pointer address use a & next to the pointer variable name\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var nameAddress = &namePointer\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"package main\\nimport \\\"fmt\\\"\\nfunc main() {\\n    var name string\\n    var namePointer *string // actually store a memory location into this name pointer variable noyt just name of string\\n\\n    fmt.Println(name) // ''\\n    fmt.Println(namePointer) // <nil> => nil means, we are expecting actual address memory not just string \\\"\\\"\\n}\\n\")), mdx(\"p\", null, \"Now, when you assign \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"namePointer\"), \" to some string value then \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"namePointer\"), \" will throw an error.\"), mdx(\"u\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func main() {\\n    var name string\\n    var namePointer *string // actually store a memory location into this name pointer variable noyt just name of string\\n    \\n    name  = \\\"Lisa\\\"\\n    namePointer = \\\"Ake\\\"  // this will throw an error, cannot use 'Ake' as type *string assignment\\n}\\n\")), mdx(\"p\", null, \"To use the namePointer as string we need to add \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"&\"), \" to the variable,\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func main() {\\n    var name string\\n    var namePointer *string // actually store a memory location into this name pointer variable noyt just name of string\\n    \\n    name  = \\\"Lisa\\\"\\n    namePointer = &name  \\n    // name is Lisa, and namePointer is like go get the address , read through the pointer,\\n    // to find the address and give back what its look like\\n\\n    fmt.Println(name) // Lisa\\n    fmt.Println(namePointer) // 0xc00010a040   =>(its giving the address of the value)\\n}\\n\")), mdx(\"p\", null, \"If you want to find the variable through the address, you will be going to dereference the variable:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func main() {\\n    var name string\\n    var namePointer *string // actually store a memory location into this name pointer variable noyt just name of string\\n    \\n    name  = \\\"Lisa\\\"\\n    namePointer = &name  \\n    // we can get the variable by address\\n    var nameValue = *namePointer\\n\\n    fmt.Println(name) // Lisa\\n    fmt.Println(namePointer) // 0xc00010a040   =>(its giving the address of the value)\\n    \\n    fmt.Println(nameValue) // Lisa\\n}\\n\")), mdx(\"h3\", null, mdx(\"mark\", null, \"Pass By Reference\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"How do you modify the variable which you can't change directly\\u2753\\uD83E\\uDD14\")), mdx(\"p\", null, \"We will Understand the concept by using examples:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"import (\\n    \\\"fmt\\\"\\n    \\\"strings\\\"\\n)\\n\\nfunc changeName(n string) {\\n    n = strings.ToUpper(n)\\n}\\n\\nfunc main() {\\n    name := 'Lisa'\\n    changeName(name)\\n    fmt.Println(name) // Lisa \\n}\\n\")), mdx(\"p\", null, \"The value is still same, you don't want to copy the value, you want actual address. So, the symbol for that was an address using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&\"), \" .\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"import (\\n    \\\"fmt\\\"\\n    \\\"strings\\\"\\n)\\n\\n// expecting type of variable to be a pointer, to be an address\\nfunc changeName(n *string) {\\n    // need to deference the n,so I really want to modify the actual value that lives here\\n    *n = strings.ToUpper(*n)\\n}\\n\\nfunc main() {\\n    name := 'Lisa'\\n    changeName(&name)\\n    fmt.Println(name) // LISA \\n}\\n\")), mdx(\"p\", null, \"Example with both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Struct\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pointers\"), \":\"), mdx(\"p\", null, \"Only in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"struct\"), \", without having dereference or adding ampersand (&) , you will actually get the address. And you can modify value in memory without having to be more explicit.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// coordinates represents lat and long(call by value)\\ntype Coordinates struct {\\n    X, Y float64\\n}\\n\\nvar c = Coordinates{X: 10, Y : 50}\\n\\nfunc main() {\\n    coordinateMemoryAddress := c\\n    coordinateMemoryAddress.X = 200\\n    fmt.Println(coordinateMemoryAddress) // {200 50}\\n}\\n\")), mdx(\"p\", null, \"Example for changing email in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User struct\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"type User struct {\\n    ID                         int\\n    FirstName, LastName, Email string\\n}\\n\\nvar u = User{\\n    ID:        1,\\n    FirstName: \\\"lis\\\",\\n    LastName:  \\\"jha\\\",\\n    Email:     \\\"li@gmail.com\\\",\\n}\\n\\nfunc updateEmail(u *User) {\\n    u.Email = \\\"Lisa@gmail.com\\\"\\n    fmt.Println(u.Email)\\n}\\n\\nfunc main() {\\n    // given pointer user in updateEmail arguments, so we can expect regular struct and we have give `&` for address\\n    updateEmail(&u)\\n    fmt.Println(\\\"u\\\", u)\\n}\\n\")), mdx(\"h2\", null, \"2\\uFE0F\\u20E3 Error Handling \\uD83D\\uDED1\"), mdx(ImgPost, {\n    src: ErrorHandling,\n    alt: \"error handling in Go\",\n    width: 50,\n    mdxType: \"ImgPost\"\n  }), mdx(\"p\", null, \"It's particularly unique functions in GO, because Go is treating every error as a value rather than exception.\"), mdx(\"p\", null, \"There are 2 kind of errors:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"mark\", null, \"Error\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It indicates that something bad has happened to application like something went wrong. But it might be possible that program does not stop, you need to handle this. i.e. A function that intentionally returns an error if something goes wrong.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"mark\", null, \"Panic\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It happens at run time and it's something that was fatal to program and program stops execution like, trying to hit an endpoint that doesn't exist.\"))), mdx(\"u\", null, \"Error Types:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"type error interface (\\n    Error() string\\n)\\n\")), mdx(\"p\", null, \"Below snippet for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"error\"), \", will show how the error comes up:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"import (\\n    \\\"errors\\\"\\n    \\\"fmt\\\"\\n)\\n\\nfunc isGreaterThanTen(num int) error {\\n    if num < 10 {\\n        return errors.New(\\\"something bad happened\\\")\\n    }\\n    return nil\\n}\\n\\nfunc main() {\\n    num := 9\\n    err := isGreaterThanTen(num)\\n    if err != nil {\\n        fmt.Println(fmt.Errorf(\\\"%d is NOT GREATER THAN TEN\\\", num))\\n    }\\n    fmt.Println(err) // something bad happened\\n}\\n\")), mdx(\"p\", null, \"Below snippet for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"panic\"), \", throw the error and stops execution of program.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func main() {\\n    num := 9\\n    err := isGreaterThanTen(num)\\n    if err != nil {\\n        panic(err) //panic: something bad happened\\n    }\\n    fmt.Println(err)\\n}\\n\")), mdx(\"p\", null, \"Below snippet for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"log\"), \", which is going to log to wherever you are keeping track of your error logs.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func main() {\\n    num := 9\\n    err := isGreaterThanTen(num)\\n    if err != nil {\\n        log.FatalIn(err) // 2020/05/06 16:20:20 something bad happened\\n    }\\n    fmt.Println(err)\\n}\\n\")), mdx(\"p\", null, \"Below snippet, you can also return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"error\"), \" as type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func openFile() error { // it returns an error type\\n    // f -> filename, err -> error\\n    // open the file\\n    f, err := os.Open(\\\"missingFile.txt\\\") // os is Operating Sysytem\\n    if err != nil {\\n        return err\\n    }\\n    // close the file\\n    defer f.Close()\\n    return nil\\n}\\n\\nfunc main() {\\n    num := 9\\n    err := isGreaterThanTen(num)\\n    if err != nil {\\n        fmt.Println(fmt.Errorf(\\\"%d is NOT GREATER THAN TEN\\\", num))\\n    }\\n    fmt.Println(err)\\n    // as we can not have two same variable name as err, so changing it to \\n    someErr := openFile()\\n    if someErr != nil {\\n        fmt.Println(fmt.Errorf(\\\"%v\\\", err))\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can use shorthand syntax as shown in below snippet, where you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"err\"), \" variable for the same function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func openFile() error { // it returns an error type\\n    // f -> filename, err -> error\\n    // open the file\\n    f, err := os.Open(\\\"missingFile.txt\\\") // os is Operating Sysytem\\n    if err != nil {\\n        return err\\n    }\\n    // close the file\\n    defer f.Close()\\n    return nil\\n}\\n\\nfunc main() {\\n    num := 9\\n    if err := isGreaterThanTen(num); err != nil {\\n        fmt.Println(fmt.Errorf(\\\"%d is NOT GREATER THAN TEN\\\", num))\\n    }\\n\\n    if err := openFile(); someErr != nil {\\n        fmt.Println(fmt.Errorf(\\\"%v\\\", err))\\n    }\\n\")), mdx(\"h2\", null, \"Panic & Defer \\uD83D\\uDE28\"), mdx(ImgPost, {\n    src: PanicDefer,\n    alt: \"panic and defer in go\",\n    width: 50,\n    mdxType: \"ImgPost\"\n  }), mdx(\"p\", null, mdx(\"mark\", null, \"defer\"), \" statements delay the execution of the function or method or an anonymous method until the nearby functions returns.\"), mdx(\"p\", null, \"Taking an example of Opening and closing a file.\"), mdx(\"p\", null, \"If the file is successfully opened, we can call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"defer\"), \" and then f.Close \"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"defer f.Close()\")), mdx(\"p\", null, \"In Panic, we can throw the error and stop exection of the program.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"panic(err.Error())\")), mdx(\"u\", null, \"Defer Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"package main\\n\\nimport (\\n    \\\"fmt\\\"\\n)\\n\\nfunc doThings() {\\n    defer fmt.Println(\\\"First Line but do this last!\\\")\\n    defer fmt.Println(\\\"Do this second to last!\\\")\\n    fmt.Println(\\\"Things And Stuff should happen first\\\")\\n}\\n\\nfunc main() {\\n    doThings()\\n}\\n\\n// Output:\\n// Things And Stuff should happen first\\n// Do this second to last!\\n// First Line but do this last!\\n\")), mdx(\"p\", null, \"In above snippet, we can see the order of the execution is different.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOTE\"), \": Defer is last in first out(LIFO) type of structure.\"), mdx(\"h3\", null, \"Recover \\uD83D\\uDE07\"), mdx(\"p\", null, mdx(\"mark\", null, \"Recover\"), \" tells \", mdx(\"b\", null, \"GO\"), \", what to do when panic happens, and return what was passed to panic.\"), mdx(\"p\", null, \"Recover must be paired with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"defer\"), \", which will fire even after a panic. So, usually after \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"panic\"), \" program, execution failed. But by pairing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"defer\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recover\"), \" you can do something after panic as well.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"package main\\n\\nimport (\\n    \\\"fmt\\\"\\n)\\n\\nfunc handlePanic() string {\\n    return \\\"HANDLING THE PANIC\\\"\\n}\\n\\nfunc recoverFromPanic() {\\n    // recover() will only return a value if there has been a panic\\n    if r := recover(); r != nil {\\n        fmt.Println(\\\"We panicked but everything is fine.\\\")\\n        fmt.Println(\\\"Panic instructions received:\\\", r)\\n    }\\n}\\n\\nfunc doThings() {\\n    defer recoverFromPanic()\\n    for i := 0; i < 5; i++ {\\n        fmt.Println(i)\\n        if i == 2 {\\n            panic(handlePanic())\\n        }\\n    }\\n}\\n\\nfunc main() {\\n    doThings()\\n}\\n\\n// Output:\\n// 0\\n// 1\\n// 2\\n// We panicked but everything is fine.\\n// Panic instructions received: HANDLING THE PANIC\\n\")), mdx(\"h2\", null, \"3\\uFE0F\\u20E3 Methods \\uD83D\\uDE05\"), mdx(ImgPost, {\n    src: Method,\n    alt: \"method in go\",\n    width: 60,\n    mdxType: \"ImgPost\"\n  }), mdx(\"p\", null, \"The difference between \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods & function\"), \" is, instead of accepting argument as struct , you are calling a method on an instance of the struct.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// Function \\nfunc describeUser(u *User) string { // we are passing struct, func taking argument u of a User type \\n    desc := fmt.Sprintf(\\\"Name: %s %s, Email: %s\\\", u.firstName, u.lastName, u.email)\\n    return desc\\n}\\n\\n//Method \\n// (u *User) => what the method is going to be called on, so what's the receiving struct of method\\nfunc (u *User) describe() string {\\n    desc := fmt.Sprintf(\\\"Name: %s %s, Email: %s\\\", u.firstName, u.lastName, u.email)\\n    return desc\\n}\\n\\nfunc main() {\\n    u := User{ID: 1, firstName: \\\"suprabha\\\", lastName: \\\"s\\\", email: \\\"supi@gmail.com\\\"}\\n    // function call\\n    desc := describeUser(user)\\n    \\n    // method call\\n    // calling a describe method on an instance of user\\n    desc := user.describe()\\n    fmt.Println(desc)\\n}\\n\")), mdx(\"p\", null, \"Method is going to be particularly concerned about state and what kind of state or information that struct is getting passed in with.\"), mdx(\"h2\", null, \"4\\uFE0F\\u20E3 Interface \\uD83D\\uDC81\\u200D\\u2640\\uFE0F\"), mdx(ImgPost, {\n    src: Interface,\n    alt: \"interface in go\",\n    width: 50,\n    mdxType: \"ImgPost\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Interface\"), \" are complex aspect of code but they are super powerful and make sure everything is readable.\"), mdx(\"p\", null, \"Interface is a list of methods that are going to describe behaviour of particular types. It describe the kind of behaviour our types can execute.\"), mdx(\"u\", null, \"Method Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func (u *User) describe() string {\\n    desc := fmt.Sprintf(\\\"Name: %s %s, Email: %s\\\", u.firstName, u.lastName, u.email)\\n    return desc\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// describer prints out enitity description\\ntype Describer interface {\\n    describe() string\\n}\\n\\nfunc describeHumand(human Describer) string {\\n    // return it, whatever struct is passed is in part our interface describer\\n    return human.describe()\\n}\\n\\nfunc main() {\\n    u := User{ID: 1, firstName: \\\"suprabha\\\", lastName: \\\"s\\\", email: \\\"supi@gmail.com\\\"}\\n    userDescWithInterface := describeHumand(&u)\\n\\n    fmt.Println(userDescWithInterface) //\\n}\\n\")), mdx(\"p\", null, \"In above snippet, If you are calling describe function then it's also getting called Describer interface because we called describe method in \", mdx(\"mark\", null, \"Describer Interface\"), \".\"), mdx(\"p\", null, \"Interface reduces a lot of duplication in code, it also encapsulates all of its behaviour and attributes.\"), mdx(\"h3\", null, \"Empty Interface \\u2205\"), mdx(\"p\", null, \"Its written as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface {}\"), \", Sometime you don't know whats coming in, whether its user or group. You don't know the key value pairs on a map(object) but you know that you accept some type of map structure.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Empty interface\"), \" specifies zero methods. It can be used to hold a value of any type.\"), mdx(\"p\", null, \"Its like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" from typeScript \\uD83D\\uDE1C\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"type User struct {}\\ntype Admin struct {}\\ntype Parent struct {}\\n\\ninterface {}\\nvar people map[string]interface{}\\n\\npeople = map[string]interface {\\n    \\\"user\\\": User,\\n    \\\"admin\\\": Admin,\\n    \\\"parent\\\": Parent\\n}\\n\")), mdx(\"p\", null, \"In this section, we learnt how to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"pointers\"), \" and struct with pointers, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Error handling\"), \" has two types panic and Error also explored Panic and Defer concept, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Methods\"), \" which get called on an instance of the struct and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Interface\"), \" helps code to be more readable.\"), mdx(\"p\", null, mdx(LinkPost, {\n    href: \"/21-basics-of-golang-part-4\",\n    name: \"Next section\",\n    mdxType: \"LinkPost\"\n  }), \" we are going to discuss following topics: Web Servers, External API, Concurrency and Channel.\"), mdx(\"p\", null, \"I hope you found this blog helpful, If you have any question please reach out to me on \", mdx(LinkPost, {\n    href: \"https://twitter.com/suprabhasupi\",\n    name: \"@suprabhasupi\",\n    mdxType: \"LinkPost\"\n  }), \" \\uD83D\\uDE0B\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/19-basics-of-golang-part-3"}},
    "staticQueryHashes": ["1691836396"]}