{
    "componentChunkName": "component---src-templates-page-index-js",
    "path": "/70-regular-vs-arrow-function",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Regular vs Arrow Function ðŸ”¥","desc":"Understand the difference between regular and arrow function","banner":{"sharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACxLAAAsSwGlPZapAAACX0lEQVQoz22RS08TYRSGZ0GJFOjQdqYz03amnem9pZcBSguFEIsUCgEaMSBgvBAvJKABgwQS0a0LN2xc6kbdmJioO+PaxF9g4q9AFyauHtMWIyYu3pzkPCfvec/3CSGvwlkZHl+rhiWVkHTalxR0r4+Qp91vS0EXZfTpBC9ezsO7y5y8XUb4n1lA9KJ0i/hdbiRHL5ONPNfuT6H29qF297VYc8Z0KyhhPxf2R/jyYRk+rv9r2FRQ9JKPJqmWK1TsIYqpHDOzEwzUsuTjKaqlCtXyGHY8TbBPIiT6CAU0xi5lef7o/F/DZrrmKc3t9YkqR/sH7GxusbVxi9lqDSHgZK42zYO7OxztH7JYq+NzujB9GkHRh9zhxuUQEUxJwThjanjaKdUeEcMtc31ljb3te9xYWeNgd4/R/AAeR1crnSkr+LpllqpBXj3N8uZ4FEHtlTBPHz/sVbCU5mdoLYVljfHBEjMTk4zZQyzUauSiqdbSsOzHlFUkp8bNRYWTr9vw4zXCYjmO2+kl4JKIqSGKhTxmNINlZTCtDIYeR1UsYoEIqUQM3UxiWf2YZoZYNItfS9OoRjj5dgjfnyF8Pq7z+HCc+lwaQ9bJJ0rY/cMUhovYxTLp3BDxeIGo2U8uWaJgD2MPF8nbJVJpm4iZJ2MaPLyd4MluGuHX+1V+flpnc6eMLGpEjARmIIYVjGHpcQwtgq5aGJpFOBhrM73NQv4o4WAUv1tD7PAgOiSEwcpVpmbukB3ZwGks0aks0Kkt0Kku0KHM02NcREutoSRX6Qo0cKht9kfn/I0WC2avIJpL/AZ4nDsvOWT4sQAAAABJRU5ErkJggg==","aspectRatio":1.9824561403508771,"src":"/static/632fbad5cd3273ac508df3baab532322/62b1f/70-regular-vs-arrow-function.png","srcSet":"/static/632fbad5cd3273ac508df3baab532322/e7519/70-regular-vs-arrow-function.png 113w,\n/static/632fbad5cd3273ac508df3baab532322/7e7e9/70-regular-vs-arrow-function.png 225w,\n/static/632fbad5cd3273ac508df3baab532322/62b1f/70-regular-vs-arrow-function.png 450w,\n/static/632fbad5cd3273ac508df3baab532322/e2e7f/70-regular-vs-arrow-function.png 675w,\n/static/632fbad5cd3273ac508df3baab532322/db955/70-regular-vs-arrow-function.png 900w,\n/static/632fbad5cd3273ac508df3baab532322/9a5f7/70-regular-vs-arrow-function.png 3072w","srcWebp":"/static/632fbad5cd3273ac508df3baab532322/b8a88/70-regular-vs-arrow-function.webp","srcSetWebp":"/static/632fbad5cd3273ac508df3baab532322/3a3bf/70-regular-vs-arrow-function.webp 113w,\n/static/632fbad5cd3273ac508df3baab532322/975bf/70-regular-vs-arrow-function.webp 225w,\n/static/632fbad5cd3273ac508df3baab532322/b8a88/70-regular-vs-arrow-function.webp 450w,\n/static/632fbad5cd3273ac508df3baab532322/761da/70-regular-vs-arrow-function.webp 675w,\n/static/632fbad5cd3273ac508df3baab532322/210c1/70-regular-vs-arrow-function.webp 900w,\n/static/632fbad5cd3273ac508df3baab532322/f75db/70-regular-vs-arrow-function.webp 3072w","sizes":"(max-width: 450px) 100vw, 450px"}}}},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Regular vs Arrow Function ðŸ”¥\",\n  \"slug\": \"/70-regular-vs-arrow-function\",\n  \"date\": \"2021-07-29T00:00:00.000Z\",\n  \"desc\": \"Understand the difference between regular and arrow function\",\n  \"cover\": {\n    \"img\": \"../../../photos/70-regular-vs-arrow-function.png\"\n  },\n  \"banner\": \"../../banners/70-regular-vs-arrow-function.png\",\n  \"tags\": [\"JS\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"span\", {\n    className: \"first-letter\"\n  }, \"D\"), \"efine your functions in many ways.\"), mdx(\"p\", null, \"One way is using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"function\"), \" keyword:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// function declaration\\nfunction test(msg) {\\n    return `Hey ${msg}`\\n}\\n\\n// function expression\\nconst test = function(msg) {\\n    return `Hey ${msg}`\\n}\\n\")), mdx(\"p\", null, \"You can call both \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"function declaration\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"expression\"), \" as Normal/Regular Function\"), mdx(\"p\", null, \"Arrow function is introduced in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ES6\"), \" and also known as fat arrow function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const arrowFunction = (msg) => {\\n    return `Hey ${msg}`\\n}\\n\")), mdx(\"p\", null, \"As you see both functions work same by above example.  Now the question comes why do we need regular or arrow function. \"), mdx(\"p\", null, \"Let's discuss below \\uD83D\\uDC47\"), mdx(\"h4\", null, \"1. \", mdx(\"a\", {\n    href: \"#syntax\"\n  }, \"Syntax\")), mdx(\"h4\", null, \"2. \", mdx(\"a\", {\n    href: \"#arguments\"\n  }, \"Arguments binding\")), mdx(\"h4\", null, \"3. \", mdx(\"a\", {\n    href: \"#this\"\n  }, \"this\")), mdx(\"h4\", null, \"4. \", mdx(\"a\", {\n    href: \"#new\"\n  }, \"new keyword\")), mdx(\"h4\", null, \"5. \", mdx(\"a\", {\n    href: \"#no-duplicate-name\"\n  }, \"No duplicate named parameters\")), mdx(\"h4\", null, \"6. \", mdx(\"a\", {\n    href: \"#function-hoisting\"\n  }, \"Function Hoisting\")), mdx(\"h4\", null, \"7. \", mdx(\"a\", {\n    href: \"#methods\"\n  }, \"Methods\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"syntax\"\n  }, \"1\\uFE0F\\u20E3 Syntax\")), mdx(\"p\", null, \"We can write normal and arrow function in this way \\uD83D\\uDE0E\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// ES5\\nvar add = function(x, y) {\\n    return x + y\\n};\\n\\n// ES6\\nlet add = (x, y) =>  x + y \\n\")), mdx(\"h3\", null, \"Implicit Return\"), mdx(\"p\", null, \"In regular function, you have to use return keyword to return any value. If you don't return anything then the function will return undefined.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function regFunc() {\\n    return \\\"Regular Function\\\";\\n}\\nregFunc(); \\n// Regular Function\\n\\nfunction regFunc() {\\n    console.log(\\\"Regular Function\\\")\\n}\\nregFunc(); \\n// Regular Function\\n// undefined\\n\")), mdx(\"p\", null, \"Arrow functions behave in the same way when returning values.\"), mdx(\"p\", null, \"If the arrow function contains one expression, you can omit the curly braces, and then the expression will be implicitly returned.\"), mdx(\"h4\", null, mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"{}\"), \" not required if its only one line of statement\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const addOne = (number) => number + 1;\\naddOne(10);\\n\")), mdx(\"h4\", null, mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"()\"), \" not required if you pass only one argument\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let add = x => x + x;\\n\")), mdx(\"h4\", null, \"If there is no arguments\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let arrowFunc = _ => console.log(\\\"Arrow Function\\\");\\n\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"arguments\"\n  }, \"2\\uFE0F\\u20E3 Arguments binding\")), mdx(\"p\", null, \"In regular function, \", mdx(\"mark\", null, \"Arguments\"), \" keywords can be used to access the arguments of which passed to function.\"), mdx(\"u\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function regularFunction(a,b) {\\n    console.log(arguments)\\n}\\n\\nregularFunction(1,2)\\n// Arguments[1,2]\\n\")), mdx(\"p\", null, \"Arrow functions do not have an arguments binding.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const arrowFunction = (a,b) => {\\n    console.log(arguments)\\n}\\n\\narrowFunction(1,2)\\n//ReferenceError: argumnets is not defined\\n\")), mdx(\"p\", null, \"However, if you want to access arguments in an arrow function, you can use the rest operator:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var arrowFunction = (...args) => {\\n    console.log(...args)\\n}\\n\\narrowFunction(1,2)\\n// 1 2\\n\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"this\"\n  }, \"3\\uFE0F\\u20E3 this\")), mdx(\"p\", null, \"In regular function, this changes according to the way that function is invoked.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Simple Invocation:\"), \"\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \"\\xA0equals the global object or maybe undefined if you are using strict mode.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Method Invocation:\"), \"\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \"\\xA0equals the object that owns the method.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Indirect Invocation:\"), \"\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \"\\xA0equals the first argument.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Constructor Invocation:\"), \"\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \"\\xA0equals the newly created instance.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// 1\\uFE0F\\u20E3 Simple Invocation\\nfunction simpleInvocation() {\\n    console.log(this);\\n}\\n\\nsimpleInvocation(); \\n// Window Object\\n\\n\\n// 2\\uFE0F\\u20E3 Method Invocation\\nconst methodInvocation = {\\n  method() {\\n      console.log(this);\\n  }\\n};\\n\\nmethodInvocation.method(); \\n// logs methodInvocation object\\n\\n\\n// 3\\uFE0F\\u20E3 Indirect Invocation\\nconst context = { aVal: 'A', bVal: 'B' };\\nfunction indirectInvocation() {\\n    console.log(this);\\n}\\n\\nindirectInvocation.call(context);  // logs { aVal: 'A' }\\nindirectInvocation.apply(context); // logs { bVal: 'A' }\\n\\n\\n// 4\\uFE0F\\u20E3 Constructor Invocation\\nfunction constructorInvocation() {\\n    console.log(this);\\n}\\n\\nnew constructorInvocation(); \\n// logs an instance of constructorInvocation\\n\")), mdx(\"p\", null, \"Arrow functions don't have their own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", and they don\\u2019t redefine the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" within the function.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" inside an arrow function always refers to this from the outer context.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var name = \\\"Suprabha\\\"\\nlet newObject = {\\n    name : \\\"supi\\\",\\n    arrowFunc: () => {\\n        console.log(this.name); \\n    },\\n    regularFunc() {\\n        console.log(this.name); \\n    }   \\n}\\n\\nnewObject.arrowFunc(); // Suprabha\\nnewObject.regularFunc(); // supi\\n\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"new\"\n  }, \"4\\uFE0F\\u20E3 new \")), mdx(\"p\", null, \"Regular functions are constructible, they can be called using the new keyword.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function add (x, y) {\\n    console.log(x + y)\\n}\\n\\nlet sum = new add(2,3);\\n// 5\\n\")), mdx(\"p\", null, \"However, arrow functions can never be used as constructor functions. Hence, they can never be invoked with the new keyword\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let add = (x, y) => console.log(x + y);\\n\\nconst sum = new add(2,4); \\n// TypeError: add is not a constructor\\n\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"no-duplicate-name\"\n  }, \"5\\uFE0F\\u20E3 No duplicate named parameters \")), mdx(\"p\", null, \"In normal function, we can do this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// \\u2705 will work \\nfunction add(a, a) {}\\n\\n// \\u274C will not work \\n'use strict';\\nfunction add(a, a) {}\\n\\n// Uncaught SyntaxError: Duplicate parameter name not allowed in this context\\n\")), mdx(\"p\", null, \"Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const arrowFunc = (a,a) => {}\\n\\n// Uncaught SyntaxError: Duplicate parameter name not allowed in this context\\n\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"function-hoisting\"\n  }, \"6\\uFE0F\\u20E3 Function Hoisting\")), mdx(\"p\", null, \"In regular function, function gets hoisting at top. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"normalFunc()\\n\\nfunction normalFunc() {\\n    return \\\"Normal Function\\\"\\n}\\n\\n// \\\"Normal Function\\\"\\n\")), mdx(\"p\", null, \"In arrow function, function get hoisted where you define. So, if you call the function before initialisation you will get referenceError.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"arrowFunc()\\n\\nconst arrowFunc = () => {\\n    return \\\"Arrow Function\\\"\\n}\\n\\n// ReferenceError: Cannot access 'arrowFunc' before initialization\\n\")), mdx(\"h3\", null, mdx(\"h3\", {\n    id: \"methods\"\n  }, \" 7\\uFE0F\\u20E3 Methods\")), mdx(\"p\", null, \"You can define methods in class using regular function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"class FullName {\\n    constructor(name) {\\n        this.name = name;\\n    }\\n    \\n    result() {\\n        console.log(this.name)\\n    }\\n}\\n\\nlet name = new FullName(\\\"Suprabha\\\")\\n\\nconsole.log(name) \\n// FullName\\xA0{name: \\\"Suprabha\\\"}\\n\")), mdx(\"p\", null, \"You need to apply method as callback also.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"setTimeout(name.result, 2000) \\n// after 1 second logs \\\"\\\"\\n\")), mdx(\"p\", null, \"But if you bind \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"setTimeout(name.result.bind(name), 2000) \\n// Suprabha\\n\")), mdx(\"p\", null, \"By above example, you can see that you have to bind the this to there context.\"), mdx(\"p\", null, \"In arrow function, you don't have to bind with context.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"class FullName {\\n    constructor(name) {\\n        this.name = name;\\n    }\\n    \\n    result = () => {\\n        console.log(this.name)\\n    }\\n}\\n\\nlet name = new FullName(\\\"Suprabha\\\")\\n\\nsetTimeout(name.result, 2000) // Suprabha\\n\")), mdx(\"h3\", null, \"When not to use Arrow function \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object Methods\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let dog = {\\n    count: 3,\\n    jumps: () => {\\n        this.count++\\n    }\\n}\\n\")), mdx(\"p\", null, \"When you call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dog.jumps\"), \", the number of count does not increase. It is because this is not bound to anything, and will inherit the value of this from its parent scope.\"), mdx(\"h2\", null, \"Reference \\uD83E\\uDDD0\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(LinkPost, {\n    href: \"https://www.geeksforgeeks.org/difference-between-regular-functions-and-arrow-functions/\",\n    name: \"GeeksForGeeks normal vs arrow function\",\n    mdxType: \"LinkPost\"\n  }))), mdx(\"h3\", null, \"Summary\"), mdx(\"p\", null, \"In regular function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" value is dynamic, In arrow function it equals to this of the outer function.\"), mdx(\"p\", null, \"In regular function, arguments will give you list of parameter passed in function, In arrow function arguments is not defined.\"), mdx(\"p\", null, \"In regular function, you always have to return any value, but in Arrow function you can skip return keyword and write in single line.\"), mdx(\"p\", null, \"In arrow function parameters should be unique.\"), mdx(\"p\", null, \"Hoisting matters in arrow function as function get not be invoked before initialisations.\"), mdx(\"br\", null), mdx(\"br\", null), \"Thanks for reading the article \\u2764\\uFE0F\", mdx(\"p\", null, \"I hope you love the article. If you have any question, feel free to ping me on \", mdx(LinkPost, {\n    href: \"https://twitter.com/suprabhasupi\",\n    name: \"Twitter\",\n    mdxType: \"LinkPost\"\n  }), \" | \", mdx(LinkPost, {\n    href: \"http://instagram.com/suprabhasupi\",\n    name: \"Instagram\",\n    mdxType: \"LinkPost\"\n  }), \" \\uD83D\\uDE0B\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/70-regular-vs-arrow-function"}},
    "staticQueryHashes": ["1691836396"]}